*** riskCheck.js	2025-09-28
--- riskCheck.js	2025-09-28
***************
*** 1,999 ****
--- 1,999 ----
+ // === PhishTank: 診断＆フォールバック強化版 ===
+ (function(){
+   function _tryParseJson(text){
+     try { return JSON.parse(text); } catch {}
+     // HTML等で返るケースに備え、最初の { ... } を強引に抽出
+     const i = text.indexOf("{"); const j = text.lastIndexOf("}");
+     if (i !== -1 && j !== -1 && j > i) {
+       try { return JSON.parse(text.slice(i, j+1)); } catch {}
+     }
+     return {};
+   }
+ 
+   async function _ptPost(url, appKey, abortSignal){
+     const form = new URLSearchParams();
+     form.set("url", url);
+     form.set("format", "json");
+     if (appKey) form.set("app_key", appKey);
+     const res = await fetch("https://checkurl.phishtank.com/checkurl/", {
+       method: "POST",
+       headers: { "Content-Type": "application/x-www-form-urlencoded" },
+       body: form.toString(),
+       signal: abortSignal
+     });
+     const text = await res.text();
+     const json = _tryParseJson(text);
+     const r = json?.results || {};
+     let verdict = "unknown";
+     if (r.in_database === true) {
+       if (r.verified === true && r.valid === true) verdict = "phish";
+       else if (r.verified === true && r.valid === false) verdict = "safe";
+       else verdict = "unknown";
+     }
+     return { verdict, raw: { status: res.status, ct: res.headers.get("content-type")||"", text }, parsed: r };
+   }
+ 
+   function _flipScheme(u){
+     try{
+       const x = new URL(u);
+       x.protocol = (x.protocol === "https:") ? "http:" : "https:";
+       return x.toString();
+     }catch{ return u; }
+   }
+   function _noQuery(u){
+     try{ const x = new URL(u); x.search=""; return x.toString(); }catch{ return u; }
+   }
+   function _peelPaths(u){
+     const out = [];
+     try{
+       const x = new URL(u);
+       const parts = x.pathname.split("/").filter(Boolean);
+       while(parts.length>0){
+         parts.pop();
+         x.pathname = "/" + parts.join("/") + (parts.length?"/":"");
+         x.search = "";
+         out.push(x.toString());
+       }
+       // ルート
+       x.pathname = "/";
+       out.push(x.toString());
+     }catch{}
+     return out;
+   }
+   function _domainOnly(u){
+     try{ const x = new URL(u); return x.origin + "/"; }catch{ return u; }
+   }
+ 
+   // 強化版ルックアップ：ステップごとの trace を返す
+   async function ptLookupDiagnose(url, appKey, { timeoutMs = 10000 } = {}){
+     const trace = [];
+     const ac = new AbortController();
+     const to = setTimeout(() => ac.abort(), timeoutMs);
+     try{
+       const tryOne = async (label, target) => {
+         const r = await _ptPost(target, appKey, ac.signal);
+         trace.push({ step: label, url: target, verdict: r.verdict, sample: {
+           in_database: r.parsed?.in_database, verified: r.parsed?.verified, valid: r.parsed?.valid, phish_id: r.parsed?.phish_id
+         }, http: r.raw.status, ct: r.raw.ct });
+         return r.verdict;
+       };
+ 
+       // 1) そのまま
+       let v = await tryOne("as-is", url);
+       if (v !== "unknown") return { verdict: v, trace };
+ 
+       // 2) https⇄http
+       const flipped = _flipScheme(url);
+       if (flipped !== url){
+         v = await tryOne("flip-scheme", flipped);
+         if (v !== "unknown") return { verdict: v, trace };
+       }
+ 
+       // 3) クエリ除去
+       const noq = _noQuery(url);
+       if (noq !== url){
+         v = await tryOne("no-query", noq);
+         if (v !== "unknown") return { verdict: v, trace };
+       }
+ 
+       // 4) パス段階的短縮
+       for (const cand of _peelPaths(url)){
+         v = await tryOne("peel-path", cand);
+         if (v !== "unknown") return { verdict: v, trace };
+       }
+ 
+       // 5) ドメイン直
+       const dom = _domainOnly(url);
+       if (dom !== url){
+         v = await tryOne("domain-root", dom);
+         if (v !== "unknown") return { verdict: v, trace };
+       }
+ 
+       return { verdict: "unknown", trace };
+     } finally {
+       clearTimeout(to);
+     }
+   }
+ 
+   // 既存公開名に合わせたラッパも提供（後方互換）
+   if (typeof globalThis.ptLookupMinimal !== "function") {
+     globalThis.ptLookupMinimal = async (u, key, opts) => {
+       const r = await ptLookupDiagnose(u, key, opts);
+       return { verdict: r.verdict, detail: r.trace?.[r.trace.length-1]?.sample || {} };
+     };
+   }
+   // 診断版を直接使えるよう公開
+   globalThis.ptLookupDiagnose = ptLookupDiagnose;
+ })();
