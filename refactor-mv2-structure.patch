*** manifest.json
--- manifest.json
@@
 {
   "manifest_version": 2,
@@
-  "permissions": [
-    "messagesRead",
-    "notifications",
-    "storage"
-  ],
+  "permissions": [
+    "messagesRead",
+    "notifications",
+    "contextMenus",
+    "storage"
+  ],
   "host_permissions": [
-    "https://safebrowsing.googleapis.com/*",
-    "https://checkurl.phishtank.com/*"
+    "https://safebrowsing.googleapis.com/*",
+    "https://checkurl.phishtank.com/*",
+    "https://www.virustotal.com/*"
   ],
-  "content_security_policy": "default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self'; object-src 'self'; connect-src 'self' https://safebrowsing.googleapis.com https://checkurl.phishtank.com;",
+  "content_security_policy": "default-src 'self'; img-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self'; object-src 'self'; connect-src 'self' https://safebrowsing.googleapis.com https://checkurl.phishtank.com https://www.virustotal.com;",
@@
-  "background": {
-    "scripts": [
-      "utils/auth.js",
-      "utils/url.js",
-      "urlSanitize.js",
-      "urlCheck.js",
-      "riskCheck.js",
-      "background.js"
-    ]
-  }
+  "background": {
+    "scripts": [
+      "utils/auth.js",
+      "utils/url.js",
+      "utils/sanitize.js",
+      "utils/notify.js",
+      "utils/spinner.js",
+      "background/providers/gsb.js",
+      "background/providers/pt.js",
+      "background/providers/vt.js",
+      "background/extract.js",
+      "background/api.js",
+      "background/bridge.js"
+    ]
+  }
 }
*** /dev/null
--- utils/sanitize.js
@@
+// utils/sanitize.js (MV2: グローバル公開)
+(function(){
+  function _stripQuotes(u){
+    if (!u || typeof u !== "string") return u;
+    u = u.trim();
+    if ((u.startsWith("<") && u.endsWith(">")) ||
+        (u.startsWith('"') && u.endsWith('"')) ||
+        (u.startsWith("'") && u.endsWith("'"))) {
+      return u.slice(1, -1);
+    }
+    return u;
+  }
+  function _deobfuscate(u){
+    return u
+      .replace(/hxxps?:\/\//ig, m => m.replace("xx","tt"))
+      .replace(/\[\.\]/g, ".")
+      .replace(/：\/\//g, "://")
+      .replace(/\s+/g, " ");
+  }
+  function _canonicalize(u){
+    try {
+      const url = new URL(u);
+      const del = ["utm_source","utm_medium","utm_campaign","utm_term","utm_content","gclid","fbclid"];
+      del.forEach(k => url.searchParams.delete(k));
+      url.hash = "";
+      url.hostname = url.hostname.toLowerCase().replace(/^www\./, "");
+      if (url.pathname !== "/" && url.pathname.endsWith("/")) {
+        url.pathname = url.pathname.replace(/\/+$/, "/");
+      }
+      return url.toString();
+    } catch { return u; }
+  }
+  globalThis.sanitizeUrl = function sanitizeUrl(raw){
+    if (raw == null) return "";
+    let u = String(raw).trim();
+    u = _stripQuotes(u);
+    u = _deobfuscate(u);
+    if (!/^https?:\/\//i.test(u) && /^[a-z0-9\-\.]+\.[a-z]{2,}(?:\/|$)/i.test(u)) {
+      u = "http://" + u;
+    }
+    return _canonicalize(u);
+  };
+})();
*** /dev/null
--- utils/notify.js
@@
+// utils/notify.js
+(function(){
+  globalThis.notify = function notify(title, message){
+    if (!globalThis.browser?.notifications?.create) return;
+    const t = String(title ?? "通知");
+    const m = String(message ?? "");
+    const icon = globalThis.browser.runtime?.getURL?.("icons/icon-48.png") || "icons/icon-48.png";
+    try {
+      globalThis.browser.notifications.create({
+        type: "basic",
+        iconUrl: icon,
+        title: t,
+        message: m
+      }).catch(()=>{});
+    } catch(e) { console.warn("notify error", e); }
+  };
+})();
*** /dev/null
--- utils/spinner.js
@@
+// utils/spinner.js
+(function(){
+  if (typeof globalThis._spin === "undefined") globalThis._spin = null;
+  globalThis.startActionSpinner = function(){
+    const s = globalThis._spin;
+    if (!s) return;
+    if (typeof s.show === "function") s.show();
+    else if (s.style) s.style.display = "";
+  };
+  globalThis.stopActionSpinner = function(){
+    const s = globalThis._spin;
+    if (!s) return;
+    if (typeof s.hide === "function") s.hide();
+    else if (s.style) s.style.display = "none";
+  };
+})();
*** /dev/null
--- background/providers/gsb.js
@@
+// background/providers/gsb.js
+(function(){
+  async function checkWithGSB(url, apiKey, { timeoutMs = 10000 } = {}) {
+    if (!apiKey) return { verdict: "unknown", details:{reason:"no_api_key"} };
+    const body = {
+      client: { clientId: "jp-spam-checker", clientVersion: "2.0.0" },
+      threatInfo: {
+        threatTypes: ["MALWARE","SOCIAL_ENGINEERING","UNWANTED_SOFTWARE","POTENTIALLY_HARMFUL_APPLICATION"],
+        platformTypes: ["ANY_PLATFORM"],
+        threatEntryTypes: ["URL"],
+        threatEntries: [{ url }]
+      }
+    };
+    const ac = new AbortController(); const to = setTimeout(()=>ac.abort(), timeoutMs);
+    try {
+      const r = await fetch(`https://safebrowsing.googleapis.com/v4/threatMatches:find?key=${encodeURIComponent(apiKey)}`, {
+        method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body), signal: ac.signal
+      });
+      const j = await r.json().catch(()=> ({}));
+      const listed = Array.isArray(j?.matches) && j.matches.length > 0;
+      return { verdict: listed ? "listed" : "clean", details: j };
+    } finally { clearTimeout(to); }
+  }
+  globalThis.checkWithGSB = checkWithGSB;
+})();
*** /dev/null
--- background/providers/pt.js
@@
+// background/providers/pt.js
+(function(){
+  async function _ptCall(u, appKey, signal) {
+    const form = new URLSearchParams({ url: u, format: "json" });
+    if (appKey) form.set("app_key", appKey);
+    const r = await fetch("https://checkurl.phishtank.com/checkurl/", {
+      method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" },
+      body: form.toString(), signal
+    });
+    const j = await r.json().catch(()=> ({}));
+    const res = j?.results || {};
+    let verdict = "unknown";
+    if (res.in_database === true) {
+      verdict = (res.verified === true && res.valid === true) ? "listed"
+              : (res.verified === true && res.valid === false) ? "clean" : "unknown";
+    }
+    return { verdict, sample: res, http: r.status, url: u };
+  }
+  async function checkWithPT(url, appKey, { timeoutMs = 10000 } = {}) {
+    const ac = new AbortController(); const to = setTimeout(()=>ac.abort(), timeoutMs);
+    const trace = [];
+    try {
+      const steps = [];
+      const flip = (u)=>{ try{ const x=new URL(u); x.protocol=(x.protocol==="https:")?"http:":"https:"; return x.toString(); }catch{return u;}};
+      const noQ  = (u)=>{ try{ const x=new URL(u); x.search=""; return x.toString(); }catch{return u;}};
+      const peel = (u)=>{ try{ const x=new URL(u); const out=[]; const parts=x.pathname.split("/").filter(Boolean);
+        while(parts.length){ parts.pop(); x.pathname="/"+parts.join("/")+(parts.length?"/":""); x.search=""; out.push(x.toString()); }
+        x.pathname="/"; x.search=""; out.push(x.toString()); return out; }catch{return [];} };
+      const dom  = (u)=>{ try{ const x=new URL(u); x.pathname="/"; x.search=""; return x.toString(); }catch{return u;} };
+
+      steps.push(url);
+      const f = flip(url); if (f!==url) steps.push(f);
+      const nq= noQ(url);  if (nq!==url) steps.push(nq);
+      steps.push(...peel(url));
+      const d = dom(url);  if (d!==url)  steps.push(d);
+
+      for (const u of steps) {
+        const r = await _ptCall(u, appKey, ac.signal); trace.push({ step:"pt", ...r });
+        if (r.verdict !== "unknown") return { verdict: r.verdict, details: r.sample, trace };
+      }
+      return { verdict: "unknown", details: trace.at(-1)?.sample, trace };
+    } finally { clearTimeout(to); }
+  }
+  globalThis.checkWithPT = checkWithPT;
+})();
*** /dev/null
--- background/providers/vt.js
@@
+// background/providers/vt.js
+(function(){
+  async function checkWithVT(url, apiKey, { timeoutMs = 15000 } = {}) {
+    if (!apiKey) return { verdict:"unknown", details:{reason:"no_api_key"} };
+    const headers = { "x-apikey": apiKey, "Content-Type":"application/x-www-form-urlencoded" };
+    const ac = new AbortController(); const to = setTimeout(()=>ac.abort(), timeoutMs);
+    try {
+      const form = new URLSearchParams({ url });
+      const submit = await fetch("https://www.virustotal.com/api/v3/urls", { method:"POST", headers, body: form.toString(), signal: ac.signal });
+      const sub = await submit.json(); const id = sub?.data?.id;
+      if (!id) return { verdict:"unknown", details:sub };
+      for (let i=0;i<12;i++) {
+        const r = await fetch(`https://www.virustotal.com/api/v3/analyses/${id}`, { headers, signal: ac.signal });
+        const j = await r.json(); const s = j?.data?.attributes?.status;
+        if (s === "completed") {
+          const stats = j?.data?.attributes?.stats || {};
+          const listed = (stats.malicious > 0 || stats.suspicious > 0);
+          return { verdict: listed ? "listed" : "clean", details: stats };
+        }
+        await new Promise(rs=>setTimeout(rs,1000));
+      }
+      return { verdict:"unknown" };
+    } finally { clearTimeout(to); }
+  }
+  globalThis.checkWithVT = checkWithVT;
+})();
*** /dev/null
--- background/extract.js
@@
+// background/extract.js
+(function(){
+  async function extractUrlsFromMessage(messageId) {
+    const full = await browser.messages.getFull(messageId).catch(()=>null);
+    if (!full?.parts) return [];
+    const urls = new Set(), stack = [...full.parts];
+    while (stack.length) {
+      const p = stack.pop(); if (!p) continue;
+      if (p.parts?.length) { stack.push(...p.parts); continue; }
+      const ct = (p.contentType||"").toLowerCase(); const body = p.body || "";
+      if (ct.includes("text/html")) {
+        try {
+          const doc = new DOMParser().parseFromString(body, "text/html");
+          doc.querySelectorAll("a[href]").forEach(a => urls.add(a.getAttribute("href")));
+          (doc.body.textContent.match(/https?:\/\/[^\s<>"']+/gi)||[]).forEach(u => urls.add(u));
+          (doc.body.textContent.match(/\b[a-z0-9.-]+\.[a-z]{2,}(?:\/[^\s<>"']*)?/gi)||[])
+            .forEach(u => { if(!/^https?:\/\//i.test(u)) urls.add("http://"+u); });
+        } catch {}
+      } else {
+        (body.match(/https?:\/\/[^\s<>"']+/gi)||[]).forEach(u => urls.add(u));
+      }
+    }
+    const out = [];
+    for (const raw of urls) {
+      const s = (globalThis.sanitizeUrl ? globalThis.sanitizeUrl(raw) : String(raw||"").trim());
+      if (s && /^https?:\/\//i.test(s)) out.push(s);
+    }
+    return out;
+  }
+  globalThis.extractUrlsFromMessage = extractUrlsFromMessage;
+})();
*** /dev/null
--- background/api.js
@@
+// background/api.js
+(function(){
+  browser.runtime.onMessage.addListener(async (msg) => {
+    try {
+      switch (msg?.type) {
+        case "extract-urls":
+          return await globalThis.extractUrlsFromMessage(msg.messageId);
+        case "check-gsb":
+          return await globalThis.checkWithGSB(msg.url, msg.apiKey);
+        case "check-pt":
+          return await globalThis.checkWithPT(msg.url, msg.appKey);
+        case "check-vt":
+          return await globalThis.checkWithVT(msg.url, msg.apiKey);
+        default:
+          return { verdict: "unknown", error: "unknown message" };
+      }
+    } catch (e) {
+      console.error("api error:", e);
+      return { verdict: "unknown", error: String(e) };
+    }
+  });
+})();
*** /dev/null
--- background/bridge.js
@@
+// background/bridge.js
+// 既存の呼び出し名に互換を持たせる（UI/古いコードからの移行用）
+(function(){
+  if (typeof globalThis.phishTankCheck !== "function") {
+    globalThis.phishTankCheck = (url, appKey) =>
+      browser.runtime.sendMessage({ type:"check-pt", url, appKey });
+  }
+  if (typeof globalThis.gsbLookupMinimal !== "function") {
+    globalThis.gsbLookupMinimal = (urls, apiKey) =>
+      Promise.all((Array.isArray(urls)?urls:[urls]).map(u => browser.runtime.sendMessage({ type:"check-gsb", url:u, apiKey })))
+        .then(list => list.filter(x => x?.verdict==="listed"));
+  }
+  if (typeof globalThis.vtLookup !== "function") {
+    globalThis.vtLookup = (url, apiKey) =>
+      browser.runtime.sendMessage({ type:"check-vt", url, apiKey });
+  }
+})();
